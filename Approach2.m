%Code for App Prob Group project
%given a .mxml file, creates a note matrix,
%using the note matrix, generates procedual music based on random walks
%
%Slightly more sophisticated generation
%Considers note/chord pairings
%
%Dependent on the XML and MIDI toolkits
%May 2018
%Andrew Martin, James Schoff, Thomas Carey

%-----------------------------
%set RNG for reproducibility
s=rng(1704570);

%load the data generated by the music XML toolkit

load('D:\Documents\Uni\2018\App Prob\Group Project\Song Data\Output.mat');
notes= all_songs.raw_merged_nmat;


%separate chords and lead
chords = getmidich(notes,1);
lead = getmidich(notes,2);

%find all the chords
chordspace = generatechordspace(chords);

%the number of chords is equal to the last chords index
numchords = chordspace(end,end);
%The range of all possible lead notes
rangeLeadNotes = range(lead(:,4)) + 1;
transprobmatrix = zeros(numchords*rangeLeadNotes);
%this allows a smaller transprobmatrix by shifting the lowest note played
%to 1, second lowest to 2, ...
leadshift = min(lead(:,4)) - 1;

%Shift the notes down based on the shift above
leadshifted = [lead(:,1:3) , lead(:,4)-leadshift , lead(:,5:end)];

%convert the second column to endtimes rather than durations
%this helps the maths later on
leadshifted(:,2) = leadshifted(:,1) + leadshifted(:,2);
chords(:,2) = chords(:,1)+chords(:,2);

%going through the notes in the chords part of the song
chordnoteindex =1;
%so that startindex gets the first note
endindex=0;
firstrun = 1;
%%generate the transition probability matrix
%------------------------------------------
while endindex<length(chords)
    %get the chord & start and end times
    startindex  = endindex+1;
    endindex    = find(chords(:,1) == chords(startindex,1),1,'last');
    starttime   = chords(startindex,1);
    endtime     = chords(endindex,2);
    
    %makes the chord
    chord = zeros(1,4);
    chord(1:endindex-startindex+1) = chords(startindex:endindex,4)';
    %find the chord's index
    [~,chordnumber] =matrixcontainsvector(chordspace(:,1:end-1),chord(1:end));
    
    
    
    %this if statement will only occur in the first while loop
    if firstrun
        %find the first lead note which occurs after starttime
        
        leadnote = leadshifted(1,4);
        oldcombo = (chordnumber-1)*rangeLeadNotes + leadnote;
        firstrun = 0;
        index = 2;
    end
    %while the notes being looked at are played
    %index was set to start of chord,
    %and this limits it to the end of the chord
    while (index <=nnotes(lead) &&leadshifted(index,2) < endtime)
        leadnote = leadshifted(index,4);
        newcombo = (chordnumber-1)*rangeLeadNotes + leadnote;
        transprobmatrix(oldcombo,newcombo) = transprobmatrix(oldcombo,newcombo) +1;
        oldcombo = newcombo;
        index=index+1;
    end
end

%simulate the random walk
markovMatrix = dtmc(transprobmatrix);
lengthSolo= length(lead);


%need to mention initial states because NaN which dtmc produces will cause issues
InitState = double(sum(transprobmatrix,2)>0);
newnotes = simulate(markovMatrix, lengthSolo,'X0',InitState);
%pick a random column (starting note/chord)
[~,pathtofollow] = size(newnotes);
newnotes = newnotes(:,randi(pathtofollow));

%Convert back to a playable format
notematrix=[];
for index=1:length(lead)
    [shiftednote,chordindex] = valuetonotechord(newnotes(index), rangeLeadNotes);
    %convert the note back to its true value
    note = shiftednote + leadshift;
    %find the chord in the chordsarray
    chord = chordspace(chordindex,:);
    %if statement so that it doesn't play the 0 note
    if chord(4) == 0
        notechordpair = [note,chord(1:3)];
    else
        notechordpair = [note,chord(1:4)];
    end
    notematrix = addtonmat(notematrix,lead(index,1),lead(index,2),notechordpair);
    
    
    
end

notematrix = [notematrix,notematrix(:,1)./(all_songs.tempo_bpm/60) , notematrix(:,2)./(all_songs.tempo_bpm/60)];
writemidi(notematrix,"Process2.mid",all_songs.tempo_bpm );



%convert back to get chord and note

    function [shiftednote,chordindex] = valuetonotechord(value, rangeLeadNotes)
        
        %recall value = (chordnumber-1)*rangeLeadNotes + shiftedLeadNote
        shiftednote = mod(value,rangeLeadNotes);
        value = value - shiftednote;
        %now value = (chordnumber-1)*rangeLeadNotes
        chordindex = (value/rangeLeadNotes) + 1;
    end

%adds the vector into the notes part of the nmat with same
    function nmat = addtonmat(nmat,starttime,duration, notecombo)
    %given a chord/note pairing, converts to the individual notes
    %and adds them to the nmat
    %nmat will have form    
    %[starttime, length, midichannel, notevalue,velocity starttime.s length.s]
        
        starttime = repmat(starttime,length(notecombo),1);
        duration = repmat(duration,length(notecombo),1);
        channel = [2;ones(length(notecombo)-1,1)];
        %making the lead slightly louder than the chords
        velocity = [110;ones(length(notecombo)-1,1).*90];
        appendtonmat = [starttime,duration,channel,notecombo',velocity];
        
        nmat = [nmat; appendtonmat];
        
    end

function chordspace = generatechordspace(chords)
%generates a matrix containing the chords in the song
%matrix will contain rows n_1, n_2, n_3, n_4, index
%where n_i is the ith note, and n_4 = 0 means there is no 4th note
chordspace=[];
%index value for the chord
index =1;
%starting index for searching
startindex = 1;
%find the last note played with the same time
endindex=0;
while endindex < length(chords)
    endindex = find(chords(:,1)==chords(startindex,1), 1,'last');
    
    %if 3 note chord
    if (endindex - startindex) == 2
        chord = [chords(startindex:endindex,4)', 0,index];
        if ~matrixcontainsvector(chordspace(:,1:end-1),chord(1:end-1))
            chordspace = [chordspace;chord];
            index = index +1;
        end
    else
        %if 4 note chord
        if(endindex - startindex) ==3
            chord =[chords(startindex:endindex,4)',index];
            if ~matrixcontainsvector(chordspace(:,1:end-1),chord(1:end-1))
                chordspace = [chordspace;chord];
                index = index +1;
            end
        else
            error("There was an error generating the Chord State Space");
        end
    end
    startindex = endindex + 1;
end
end

function [contains ,index]= matrixcontainsvector(matrix,vector)
%checks if a matrix of size (nxm) contains a vector of size(1xm)
[n,~] = size(matrix);
for j=1:n
    if isequal(matrix(j,:),vector)
        contains = 1;
        index = j;
        return;
    end
    
end
contains=0;
index=0;
end